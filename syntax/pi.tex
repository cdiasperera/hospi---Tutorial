\todo{Ask Prof: I guess this is technically a session based $\pi$-calc. Worth specifying?}
\subsubsection{Process Syntax}
A process, in $\pi$-calculus, is defined recursively. With the fundamental operation being the ability to output values and to take in inputs, in some manner. To this end, we need to define a very what values can actually be passed. For the specification, we restrict ourselves to boolean values $\verb`true`, \verb`false`$, and of course, channel names themselves, which we will use the variables $x,y,z$ to range over\footnote{You might consider this quite limiting. Perhaps you'd like to pass around object, a la an Object-Oriented Programming paradigm, and call methods upon that object. Alas, this specification does not extend that ability, but there are extensions that be applied to $\pi$-calculus to allow this facility, see $https://www.di.fc.ul.pt/~vv/papers/vasconcelos_session-types-programming.pdf$. }.\todo{cite properly}

Thus, if we let $v$ range over all possible values, we have:

\begin{align*}
    v ::= x \mid \text{true} \mid \text{false}
\end{align*}

Now, we will consider actually defining processes. It is defined recursively, so we will need some ``base" process, which we denote as $\ep$.

Thus, let us let $P,Q,R$ range over processes. We initially have:

\begin{align*}
    P ::= \ep
\end{align*}

Next, we want some means of actually transferring values. Let us imagine a channel double-ended line, which processes can speak/listen at each end. To ``declare" such a line, we have the following syntax\footnote{Observe the seemingly recursive syntax. Readers unfamiliar with BNF notation might beleive that the $P$ on the LHS and RHS refer to the same process. However, this is an incorrect reading. Really, this defines a rewriting rule which says ``any instance of $P$ can be rewritten as the LHS. Of course, this can lead to an infinite process, but it could just as easily be finite ending with $\ep$, instead.}:

\begin{align*}
P ::= (\rest xy)P
\end{align*}

This declares that the resulting process $P$ can use $x,y$ are opposite endpoints of the same channel. You might wonder the use of this, since isn't the purpose of endpoints so that processes can communicate? Keep reading, it will be clearer as we move forward.

Also note that in this process, we declare $x,y$ to be ``new" with respect to any other channel point everywhere. That is, we can only ``correctly" use $\rest$ upon $x,y$ if $x,y$ is used no where else in the process, either internally, or in processes that are in parallel with it. This is actually only enforced via the typing rules.

\todo{Note that you can have multiple processes outputting / inputting along the same channel. Chosen non-deterministically.}

\begin{align*}
    P ::= \bar{x}v.P
\end{align*}

To mean that a process outputs the value $v$ on the channel $x$, and then continues as some other process. Note that in a well-defined process, by the time that the action is ``evaluated", $x$ will actually be a channel itself.

We define input processes as such:

\begin{align*}
    P ::= x(y).P
\end{align*}

This means that upon channel $x$, we get some input, and any instance of $y$ in $P$ is replaced with the value we picked up.

Note two things: These intuitions of what these terms represent isn't defined at all, you're currently just being told it does that. Operational semnatics will more formally define these concepts. Secondly, observe that currently, any arbitrary value can be put into $y$. This is dangerous, since perhaps the resulting process excepts $y$ to be a channel. Typing will prevent such a situation!

Now, the key operator is the parallelization operator. In $\pi$-calculus, we actually define two processes that are in parallel to be a process itself!

\begin{align*}
    P ::= P_1 \mid P_2
\end{align*}

Now, the $\rest$ operator makes a bit more sense. The two processes in parallel can communicate through the channel. For example, $(\rest xy) Q \mid P$, can have $Q$ and $P$ communicate if $Q$ uses $x$ as a channel endpoint and $P$ uses $y$ as a channel endpoint.

In some sense, this is the ``core" of $\pi$-calculus. However, we can extend it in a few useful ways:

Thus far, we haven't introduced any syntax that takes advantage of the boolean value. To introduce the familiar concept of conditional statements, we have the following syntax:

\begin{align*}
    P ::= \ifelsethen{v}{P_1}{P_2}
\end{align*}

This is a process where if the received value $v$ is $\text{true}$ then $P_1$ is run, otherwise $P_2$ is run.

Furthermore, our syntax is constantly progressing our process towards an end state, though perhaps we might wish that the process continues indefinitely. As a more practical matter, if we wish for our process to take in 100 inputs, writing such a process would be laborious. To this end, we intro the $\un$ and $\lin$ prefixes:

\begin{align*}
    q ::= \un \mid \lin
\end{align*}

which prefix our input types (thus resulting in a slight modification for our input definition:

\todo{Ask Prof: Why do we only allow this qualifier syntax for inputs? Why can't any operation have this?}
\todo{Define guard}
\begin{align*}
    P ::= q x(y).P
\end{align*}

An input action prefixed by $\lin$ corresponds to our current understanding of input actions, meaning that once the input is taken, the subsequent process runs with the corresponding substitution.

However, if the input action is prefixed by $\un$, then this \textit{also} implies a \textbf{new} process spawns that is exactly the same as the process, before the input arrived. Or equivalently (and this is the interpretation we will be proceeding with), we spawn a process $P[v/y]$ (where $v$ is the value being inputted), and the process continues, acting as if nothing happened.

Lastly, suppose we wished to offer a selection of possible processes that might run, after some input. This somewhat can be done with our conditional processes mentioned earlier, with a logarithmically scaling amount of input actions required before a choice can be made. $\pi$-calculus offers concise notation:

\begin{align*}
    P &::= x \offer \set{l_i : P_i}_{i \in I} \\
    P &::= x \select l.P 
\end{align*}

The top process indicate that it expects another process to send through channel $x$ a label from the set $I$, upon which it will run the corresponding process. The bottom process indicates that the process will send label $l$ through channel x.

\todo{Put an example of an invalid process here}

\subsubsection{Operational Semantics}

When discussing the syntax for processes above, we gave some intuitions for what that syntax meant, in terms of how it interacted with other processes, i.e: how that term contributes to overall process evolution. Broadly, this is known as the \textbf{operational semantics} of $\pi$-calculus, and we will now more formally describe these.

These are written as reductions with the $\ra$ relation. Informally, you can interpret $P \ra P'$ to mean that $P$ becomes $P'$ after one step of the evolution (i.e: a \textit{reduction}).

The first rule we introduce involve value passing into an input action with the $\lin$ qualifier\footnote{Observe the notation $Q[v/z]$. You can interpret this as re-writing $Q$ except we replace all instances of $z$ with $v$. Note there are some intricacies involved, involving the notions of $\alpha$-conversion, but we do go into that right now.}:

$$(\rest xy)(\bar{x}v.P \mid \lin y(z).Q \mid R) \ra (\rest xy)(P \mid Q[v/z]\mid R)$$

This rule dictates that if from process $\bar{x}v.P$ we are outputting value $v$ from endpoint $x$, and if there is a corresponding endpoint $y$ for some input action for process $\lin y(z).Q$, then the former process sends $v$ along that channel and evolves into $P$, with the latter process evolving into $Q$ but replacing all instaces of $z$ in $Q$ with $v$. As you can see, other processes (encapsulated by $R$) proceed unaffected.

A similar rule involves value passing into an input action with the $\un$ qualifier:

$$(\rest xy)(\bar{x}v.P \mid \un y(z).Q \mid R) \ra (\rest xy)(P \mid Q[v/z]\mid \un y(z).Q \mid \mid R)$$

This rule dictates the same semantics as the previous rule, with the exception that using $\un y(z).Q$ replicates it.

The last rule we present for communication involves communication via labels\footnote{If you're unfamiliar with this notation $\frac{P}{Q}$, it simply shorthand for $P \Rightarrow Q$. Furthermore, large bodies of whitespace correspond to a conjunction. That is to say $\frac{P \quad Q}{R}$ is shorthand for $\frac{P \land Q}{R}$. Finally, if you see $\frac{}{Q}$, this means that $Q$ is unconditionally true}:

$$\frac{j \in I}{(\rest xy)(x \select l_j . P \mid y \offer \set{l_i : Q_i}_{i \in I} \mid R) \ra (\rest xy)(P \mid Q_j \mid R)}$$

This rule dictates that if you have a process that offers various processes along endpoint $y$, if another process is sending an applicable label along the corresponding endpoint $x$, then the former process evolves into the selected process, and the latter process proceeds with whatever other work it is going to do.

One interesting observation you might have made at this point is that all these rules occur under a restriction ($\rest$) of the endpoints for the channel being used to pass values / labels. Indeed, this suggests that well-formed $\pi$-calculus processes can only communicate with another endpoint if those endpoints are first related as being corresponding endpoints of a channel.

The following rules relate to ``internal" evolution, where if a process can evolve without outside interference, it can also do so, if it is in parallel with another operation, or if it under restriction of some channel:

$$
\frac{P \ra P'}{P \mid Q \ra P' \mid Q} \\
\frac{P \ra P'}{(\rest xy)P \ra (\rest xy) P')}
$$

You might be curious why the former rule doesn't have an equivalent rule, for $Q \ra Q'$. We will see that \textbf{structural congruence} (defined below) covers this implicitly.

The last rule we present has to do with structural congruence explicitly, which says that ``equivalent" processes can follow the same reduction steps. This corresponds to our intuition of equivalence, since processes that we deem equivalent should be able to evolve in the same manner (if it cannot, it begs the question of why we consider them equivalent):

$$
\frac{P \equiv P' \quad P' \ra Q' \quad Q \equiv Q'}{P \ra Q}
$$

\subsubsection{Structural Congruence}
As mentioned earlier, we discussed this notion of ``equivalent processes". In some sense, these are processes that ``should" follow the same behavior, if we define our syntax correctly. We define equivalent processes via the equivalence relation $\equiv$.

Firstly, we observe that since the $\ep$ does ``nothing", putting it into parallel with another process (or defining some channel upon it) does nothing:

\begin{align*}
P \mid \ep &\equiv P \\
(\rest xy) \ep &\equiv \ep
\end{align*}

Next, we wish to define our parallel composition operator to be both commutative and associative:
\begin{align*}
P \mid Q &\equiv Q \mid P \\
P \mid (Q \mid R) &\equiv (P \mid Q) \mid R
\end{align*}

Similar to the commutative rule, observe that it doesn't matter in which order we declare our channel endpoints:

$$
(\rest xy)(\rest wz)P \equiv (\rest wz)(\rest xy)P
$$

Next we define how how $\ifelsethen{}{}{}$ actually operates \footnote{You might wonder if this couldn't have been defined as part of the operational semantics. It potentially could've, but note that defining something to be structurally congruent is actually a stronger claim, and thus, it is defined in this manner}
\todo{Ask prof: Why don't we define the true/false struct cong as op sems?}

\begin{align*}
\ifelsethen{\text{true}}{P_1}{P_2} &\equiv P_1 \\
\ifelsethen{\text{false}}{P_1}{P_2} &\equiv P_2
\end{align*}

Lastly, suppose we have some process $(\rest xy)P$. This means that $x,y$ is only used within $P$. If you parallely compose it with $Q$ which does not ``outwordly" use $x,y$, it means you can expand the scope of the restriction over it:


What do we mean by ``outwordly" compose? This means that you could, in principle, rename the $x,y$ in $Q$ without changing the behavior of $Q$. In a formal sense, we say that these $x,y$ in $Q$ are ``bound" to $Q$. All such $x,y$ in $Q$ are in the set $bv(Q)$. Any other identifiers in $Q$ that are not in $bv(Q)$ are in $fv(Q)$. So we formally express this intuition as:

$$
x,y \notin fv(Q) \implies (\rest xy)P \mid Q \equiv (\rest xy)(P \mid Q)
$$

\todo{Probs put this in the appendix, check with Prof about labels}

So which values are in $fv(Q)$? We can perform this inductively, upon the structure of a process:

\begin{itemize}
    \item $\ep$: No free variables are added
    \item $\bar{x}v.P$: $fv(P), x,v$ are added to the list of free variables
    \item $q x(y).P$: $fv(P), x$ is added to the list of free variables but $y$ is \textbf{not}. This is because if we wanted to use $y$ at some other restriction, we can simply rename $y$ and all instance of $y$ in $P$.
    \item $P_1 \mid P_2$: $fv(P_1), fv(P_2)$ are added to the list of free variables
    \item $(\rest xy)P$: $fv(P)$ is added to the list of free variables but \textbf{not} $x,y$. Again, if we wanted to use $x,y$ in some other restriction, we can rename all instances of it in $P$ as well to something else.
    \item $\ifelsethen{v}{P_1}{P_2}$: $v,P_1, P_2$ are added
    \item $x \offer \set{l_i : P_i}_{i \in I}$: $x$ and $\forall i \in I: fv(P_i), l_i$ are added to
    \item $x \select l.P$: $x, fv(P), l$ are added
\end{itemize}

\subsubsection{Typing rules}
As mentioned earlier, our syntax surrounding $\pi$-calculus is too loose, in that they don't necessarily conform to our intuition behind their usage, or you can create processes that do nothing / don't make sense. To resolve this, we turn to typing.

Now, we do not actually type processes, since processes aren't true values of calculus. Rather, what we are (mainly) typing is the ``behavior" of channel endpoints themselves. That is, if we have some process, its free names must correspond to some protocol (as specified by the type of that endpoint). We consider this information (regarding channel typing) the ``context" of our process.

Making sure that our processes satisfy its context is a recursive process, as processes are built on top of processes. As we delve deeper into a process to ensure it's satisfaction of a type, the context required for the evaluation will also change\footnote{As a brief concrete example, evaluating the a process under restriction will bring the channel under restriction into the context, thus evolving our context.}, and these modified contexts are what allows us to ensure the internal consistency of our processes\footnote{Note that this explanation might be too abstract, which is fine. It becomes clearer once you see the actual rules and some examples}.

Before we turn to typing, we will introduce one one concept upon channels. Recall we mentioned that free variables in a process need to correspond to some protocol. Some protocols require that a channel endpoint can only be used by \textbf{one} process. That is, it cannot jump between processes. To this end, we specify such endpoints with $\lin$, and other endpoints with $\un$.

Note that it's important to decouple the meanings of $\lin, \un$ with respect to typing channel endpoints and the effects of $\lin, \un$ with respect to its application on input channels. This is an unfortunate \todo{Ask Prof: Feels unfortunate to me?} matter of notation.

Now, before we define these typing rules, we need some means of actually \textit{writing} a type, which we now present.

We define a type $T$ recursively, with a base case being the type of channel endpoint that does nothing (i.e: $\ep$) and a Boolean value, respectively:

$$
T ::= \et \mid \bool
$$

Now, suppose a process involves either:
\begin{itemize}
    \item Restriction
    \item Parallelization
    \item A conditional choice
\end{itemize}

If you consider it, these operations do not actually involve the usage of a channel, and thus, it's affect on a channel is not reflected in its type. Of course, restriction does place some additional restraints on a channel, but these restraints will be reflected in the typing rules. Thus, these operations do not have any explicit terms associated with it!

However, the remaining operators (input / output / branching / selection ) \textit{do} involve the usage of a channel, and they have the following syntactic elements:

$$
p ::= !T_1.T_2 \mid \ ?T_1.T_2 \mid \&\set{l_i : T_i}_{i \in I} \mid \oplus \set{l_i : T_i}_{i \in I}
$$

If we have some statement $x : T$, with $T$ being some type form from above:
\begin{itemize}
    \item This channel outputs a value with type $T_1$ and then channel $x$ acts according to $T_2$
    \item This channel takes in an input with type $T_1$ and then channel $x$ acts according to $T_2$
    \item This channel takes in some label $l_i$, and then acts as $T_i$, for each $i \in I$
    \item This channel outputs some label some label $l_i$, and then acts as $T_i$, for each $i \in I$.
\end{itemize}

If you read the last two type carelessly, you might be led to believe that a label has a type, but $T_i$ reflects the \textit{continuation type} of a channel, after the corresponding action has been taken. Furthermore, for a selection type ($\oplus$), the type $T_i$ is the continuation type for the process that is doing the selection, and is not the continuation type for the other process that responds to the selection.

Observe that we define $p$, but not additional elements of $T$. This is because all these operations act on a channel, which can be linear  or unrestricted. In this sense, it is a \textbf{pretype}.

To use it, we have to combine it with a the linear ($\lin$) or unrestricted ($\un$) \textbf{qualifier}:

$$
T ::= q\ p
$$

Lastly, one might wonder how we type a process that is replicating (that is, has a $\un$ prefix). To do this, we essentially explicitly type it as such:

$$
T ::= \mu a.T
$$

This is relatively novel syntax, but essentially, it defines $a$ to be a type variable that may appear in $T$, that represents $T$ itself. So, for example

$$
\mu a. \un ?\ bool . a
$$

is equivalent to

$$
\mu a . \un ?\ bool . \un ?\ bool . a
$$

showing that we can endlessly replicate the $T$ part of $\mu a . T$, hence typing replication.

Lastly, recall we spoke of a context. We formalize this notion in $\Gamma$, where $\Gamma$ is the context under which our typing rules are evaluated:

$$
\Gamma ::= \emptyset \mid \Gamma, x : T
$$

This reads that the base context is the empty set, and we can add to this context via appending the type of a value $x$.

And thus, this defines our typing syntax!


\textbf{Note: The rest of this subsection discusses and presents how typing rules actually enforce all the intuitions / assertions of the behavior of syntactic elements we've since discussed. It's not essential to read, but reading this section will probably fix any incorrect understanding of those intuitions. A more practical reader would probably skip this section and come back when a type doesn't seem to work as expected.}

First, we will type actual values, such as channels and boolean values. Recall that processes aren't values themselves, in the sense you cannot pass processes through channels. Such typing rules will have form:

$$
\Gamma_1 \vdash v : T ; \Gamma_2
$$

where $v$ is either a channel variable or a boolean variable. This reads as: $v$ is typed as $T$, where with a ``remaining" context $\Gamma_2$. This principle here is that $\Gamma_2$ contains the context that the ``next" typing rule must be evaluated against. It's main purpose is to ensure if $x$ is a linear channel, $\Gamma_2$ does not contain a context that has $x$.

The rules are as follows:
\todo{Explain Rules}

\begin{gather*}
\frac{}{\Gamma \vdash \true : \bool ; \Gamma} \\
\frac{}{\Gamma \vdash \false : \bool ; \Gamma} \\
\frac{}{\Gamma_1, x : \lin p , \Gamma_2 \vdash x : \lin p; (\Gamma_1, \Gamma_2)} \\
\frac{\unf{T}\footnote{This makes sure that $T$ is defined along a unrestricted channel or is a boolean value.}}{\Gamma_1, x : T , \Gamma_2 \vdash x : T; (\Gamma_1, x : T, \Gamma_2)} \\
\end{gather*}

Note that $\unf{T}$ is simply a function that ensures 

The first two rules are fairly straight-forward. It says that it types $\true, \false$ as booleans. The latter two are what are of interest:
\begin{enumerate}
\item The third rule says that if $x$ if a linear endpoint in the input context, $x$ is typed as a linear endpoint. However, the output context does \textit{not} contain $x$. This is how we ensure that $x$ is used in a single process, since any other process that rely on $x$ will not contain $x$ in the context when typing the other processes.
\item This rule basically ensures that $x$ is defined in the context, and since the output context contains $x$ it must also ensure that $x$ isn't a linear endpoint, which is what $\unf{T}$ does.
\end{enumerate}

Now, we will give the typing rules associated with processes. Recall that we do not type processes directly. The purpose of the subsequent typing process is two-fold.

\begin{enumerate}

\item These typing rules will define under what conditions a process may exist, based on our input context and process we are typing. This allows us to recursively check each condition to validate the typing rule. For example, suppose we were checking $(\rest xy) P$. One condition of the associated typing rule involves extending the input context to contain the restriction and then check if $P$ is a valid process.  
\item These typing rules also define how a context evolves. For example, suppose we were type checking a parallel process $P \mid Q$. We will type check $P$ and $Q$ separately, but we ensure that the correct context is used to check $Q$ by evaluating $P$ first and using the ``remaining" context that it provides.
\end{enumerate}

To this end, the typing rules associated with processes are written as follows: $\Gamma_1 \vdash P : \Gamma_2 : L$, where $L$ is a set of variables. We read this as follows:
\begin{quote}
    If we type-check $P$ with context $\Gamma_1$, the remaining context is $\Gamma_2$ and $L$ contains all the variables consumed by $P$. The idea here is that $L$ is used in another typing rule to ensure that the variables in $L$ aren't used in that typing rule.
\end{quote}


As you encounter each typing rule (or pair of corresponding rules) we will provide an intuition behind the rule on how to read it, and the purpose of the rule, in terms of the behavior it is trying to enforce.
\todo{Change this a bit}

Because processes are written recursively, naturally the typing rules are written recursively. As $\ep$ is the base process, our first typing rule involves typing $\ep$, as you might expect:

$$
\Gamma \vdash \ep ; \Gamma ; \emptyset
$$

This rule is read as ``You can type $\ep$ with any context, with the remaining context being the input context, and it uses no linear variables".

$$
\frac{\Gamma_1 \vdash P : \Gamma_2 ; L_1 \quad \Gamma_2 \td L_1 \vdash Q : \Gamma_2 ; L_2}{\Gamma_1 \vdash P \mid Q : \Gamma_3 ; L_2}
$$

The idea behind this rule is that it types the two parallel processes independently, but it gets the set of linear variables used by $P$ and makes sure that $Q$ can be typed correctly without having that variable in the context.

$$
\frac{\Gamma_1, x : T, y : \bar{T} \vdash P : \Gamma_2 ; L}{\Gamma_1 \vdash (\rest xy : T) P : \Gamma_2 \td \set{x,y} ; L \setminus \set{x,y}}
$$

The idea here is that to type a process under restriction, if we lift those channels endpoints to the greater context, it should be able to type the inner process. Observe that $(\rest xy : T)$. To improve the efficiency of the type-checking algorithm, we must supply the type of the restricted channel endpoints when we check our process. In principle, we should know this when we type our process, since we should be using our restricted channel inside $P$, and we type $T$ along how it's used in $P$.

$$
\frac{\Gamma_1 \vdash v : q\  \bool ; \Gamma_2 \quad \Gamma_2 \vdash P : \Gamma_3 ; L \quad \Gamma_2 \vdash Q : \Gamma_3 ; L}{\Gamma_1 \vdash \ifelsethen{v}{P}{Q} : \Gamma_3 ; L}
$$

The idea here is that we check that $v$ is indeed a boolean variable, and that $P$ and $Q$ are type-correct under the same context, since they will be run in the same context, after one is chosen to be run.

The next pair of rules define passing values along a channel

$$
\frac{\Gamma_1 \vdash x : q ! T . U ; \Gamma_2 \quad \Gamma_2 \vdash v : T ; \Gamma_3 \quad \Gamma_3 + x : U \vdash P : \Gamma_4 ; L}{\Gamma_1 \vdash \bar{x}v.P : \Gamma_4 ; L \cup (\ifelsethen{q = \lin}{\set{x}}{\emptyset})} \\
$$

To check outputting along a channel, we have three jobs (corresponding to the three pre-conditions in this typing rule):
\begin{enumerate}
    \item We have to make sure that the context expects $x$ to be used as an output endpoint. We do this directly, and pick up the continuation type in $U$ and the value type in $T$.
    \item That the value we are outputting ($v$) corresponds to the type that the context expects our output to be ($T$)
    \item That if we continue $x$ as the expected continuation type ($U$) that the context expects, then $P$ will still be typed correctly.
\end{enumerate}

Observe that we correctly get the linear variables used by process $P$ into $L$, which we add $x$ to if it is expected to be linear by the context.

$$
\frac{\Gamma_1 \vdash q_2?T.U ; \Gamma_2 \quad (\Gamma_2, y : T) + x : U \vdash P : \Gamma_3 ; L \quad q_1 = \un \implies L \setminus \set{y} = \emptyset}{\Gamma_1 \vdash q_1 x(y) . P : \Gamma_3 \td \set{y} ; L \setminus \set{y} \cup  (\ifelsethen{q_2 = \lin}{\set{x}}{\emptyset})}
$$

To check input along a channel, we again have three jobs:
\begin{enumerate}
    \item We have to make sure that the context expects $x$ to be used as an input endpoint. We do this directly, and pick up the continuation type in $U$ and the value type in $T$.
    \item If we add $y$ to the context with the expected type for it ($T$), $P$ is still well-typed. 
    \item If $x(y)$ is a replicating input (i.e: has $\un$ applied to it), then it cannot contain any linear variables, since the replication will result in the linear variable being used in multiple threads (the current thread and the thread it spawns). $L$ is the set of linear variables used by $P$, and we ensure that it is basically empty, except perhaps for $y$. We can use $y$ since $y$ is a ``local" variable in $P$.
\end{enumerate}

For our output, we ensure that $y$ is not present in the output context / set of linear variables, and that we add $x$ to the set of variables that shouldn't be used in another thread ($L$) if $x$ is a linear endpoint.

The next pair of rules define branching / selection.

$$
\frac{\Gamma_1 \vdash x : q \& \set{l_i : T_i}_{i \in I} ; \Gamma_2 \quad \forall{i \in I}:\Gamma_2 + x : T_i \vdash P_i : \Gamma_3 ; L_i \quad \forall{i,j \in I} : L_i \setminus \set{x} = L_j \setminus \set{x}}{\Gamma_1 \vdash x \offer \set{l_i : P_i}_{i \in I} : \Gamma_3 ; L \cup (\ifelsethen{q = \lin}{\set{x}}{\emptyset})} \\
$$

To type-check a channel that offers multiple process pathways we need to:
\begin{enumerate}
    \item Check that the context expects $x$ to branch with the same labels as the process.
    \item That if the process branches on label $l_i$, then the process continues as type $T_i$.
    \item That each pathway uses the same linear variables, though they may differ with respect to using $x$. \todo{Why?}
\end{enumerate}

$$
\frac{\Gamma_1 \vdash x : q \oplus \set{l_i : T_i}_{i \in I} ; \Gamma_2 \quad \Gamma_2 + x : T_j \vdash P : \Gamma_3 ; L \quad j \in I}{\Gamma_1 \vdash x \select l_j.P : \Gamma_3 ; L \cup (\ifelsethen{q = \lin}{\set{x}}{\emptyset})}
$$

To type-check a channel that requests the other endpoint user to branch, we need to:
\begin{enumerate}
    \item Check that the context expects $x$ to request a branching operation, with the same labels
    \item That the subsequent process type-checks correctly, with the corresponding continuation type for $x$ based on the label selected.
    \item That the label selected is one that that the context expects for $x$. Note that it does \textbf{not} check that the label exists at the corresponding branching process.
\end{enumerate}

% \subsubsection{Table of rules}
\todo{pi table}