A keen reader might have noticed that while we have defined (if at a very high level) how a process might be defined, we have not discussed how processes actually \textit{evolve} over time, especially in the context of running concurrently with other processes. And after all, this was the source of difficulty in concurrent, as discussed earlier.

Fear not, as this is taken into account in the theory of the $\pi$-calculus, in the form of a \textbf{reduction}. A reduction is essentially a relation, mapping one process to another. Furthermore, since processes can themselves be a parallel composition of other processes, through reduction semantics, we can evolve our processes, into different processes. A more formal notion of this is discussed in Section \ref{pisyn}.

Note that ``reduction" might be a misleading phrase. A process does not necessarily get ``smaller" after a reduction, nor is it necessarily closer to ``finishing". Indeed, it could become ``bigger" by creating new processes, while still maintaining its effective size. This maps to our real-world conception of processes as well, like a client-server, with the server creating more services (i.e: processes) that clients might connect to. Furthermore, these services are well defined but their evolution does not mean they are closer to finishing. They might wish to be online forever.